java.nio全称java non-blocking IO，是指jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。

简介编辑
Sun 官方标榜的特性如下： 为所有的原始类型提供(Buffer)缓存支持。字符集编码解码解决方案。 Channel ：一个新的原始I/O 抽象。 支持锁和内存映射文件的文件访问接口。 提供多路(non-blocking) 非阻塞式的高伸缩性网络I/O 。

描述编辑
定义作为数据容器的缓冲区，并提供其他 NIO 包的概述。
NIO API 的集中抽象为：
缓冲区，它们是数据容器；
字符集及其相关解码器 和编码器，
它们在字节和 Unicode字符之间进行转换；
各种类型的通道，它们表示到能够执行 IO 操作的
实体的连接；以及选择器 和选择键，它们与
可选择信道 一起定义了多路的、无阻塞的
I/O 设施。
java.nio 包定义了缓冲区类，这些类用于所有 NIO API。java.nio.charset包中定义了字符集API，java.nio.channels包中定义了信道和选择器 API。每个子包都具有自己的服务提供程序接口(SPI) 子包，SPI 子包的内容可用于扩展平台的默认实现或构造替代实现。
缓冲区
描述
Buffer 位置，界限和容量；
清除，反转，重绕和标记/重置
ByteBuffer Get/put，压缩，查看；分配，包装
MappedByteBuffer 映射到文件的字节缓冲区
CharBuffer Get/put，压缩；分配，包装
DoubleBuffer ' '
FloatBuffer ' '
IntBuffer ' '
LongBuffer ' '
ShortBuffer ' '
ByteOrder 字节顺序的类型安全的枚举

通道编辑
Channel是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流，而且他们面向缓冲区的。
正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。
通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道 可以用于读、写或者同时用于读写。
因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。

缓冲区编辑
是一个固定数据量的指定基本类型的数据容器。除内容之外，缓冲区还具有位置 和界限，其中位置是要读写的下一个元素的索引，界限是第一个应该读写的元素的索引。基本 Buffer 类定义了这些属性以及清除、反转 和重绕 方法，用以标记 当前位置，以及将当前位置重置 为前一个标记处。
每个非布尔基本类型都有一个缓冲区类。每个类定义了一系列用于将数据移出或移入缓冲区的 get 和 put 方法，用于压缩、复制 和切片 缓冲区的方法，以及用于分的异类或同类二进制数据序列），访问要么是以 big-endian字节顺序进行，要么是以 little-endian 字节顺序进行。

判断编辑
由于客户端断开连接时，服务器端SocketChannel不会立即自动改变连接状态，其仍然可以read（）。所以通常以read（）返回值进行判断。当read（）返回为-1时即判断该连接断开。即当channel读到末尾后仍然没有数据发送，服务器即断开连接。

初始版本编辑
从以下版本开始：
1.4